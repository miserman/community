---
title: "Build a Data Site"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Build a Data Site}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

*Built with R 
`r getRversion()`
on 
`r format(Sys.time(),'%B %d %Y')`*

***

# Basic example
Building a datasite consists of 3 steps:

1. Initialize the site
2. Add data to the site
3. Specify the site's layout

## 1. Initialize
Start by loading the library and initializing a site. 
```r
library(community)

# this can be in an existing or new directory
# for this example, it is a temporary directory
dir <- paste0(tempdir(), "/example_site")
init_site(dir)
```

## 2. Add Data
Now you should have a `data` folder in `dir` where you can put your data files, and a
`build.R` file which you can use to reformat those files if needed, and add them to the site.

```r
# make a simple example set
data <- data.frame(
  id = formatC(1:78, width = 2, flag = "0"),
  matrix(rnorm(234), 78, dimnames = list(NULL, c("x", "y", "z")))
)
  
# write that set to a file
write.csv(data, paste0(dir, "/docs/data/data.csv"), row.names = FALSE)

# add it to the site
data_add(paste0(dir, "/docs/data/data.csv"))
```

This sets up the data's metadata (written to `datapackage.json`), which the site will use when it's built.

Including this code in `build.R` is not necessary, but can be a way to organize things, and make any data
processing steps repeatable.

Including the original data (`data.csv` in this case) is not also strictly necessary -- the data file made
when you build the site (by default) is all that will actually be used by the site.

## 3. Specify
Everything to do with the look and functionality of the site happens between `site.R`
and the `site_build` function.

For an initial site, replace the template content of `site.R` with this:
```r
page_navbar("Site Title")
output_plot("x", "y", "z")
```

Then save and build the site:
```r
site_build(dir, bundle_data = TRUE, open_after = TRUE)
```

`bundle_data` specifies that the data should be included in the site's index file,
rather than a separate one. This is nice for running locally or for small datasets, but when the site is being
served publicly, it might be better to keep the data separate.

`open_after` just opens the build page in a browser, which might get annoying as you edit and rebuild the site.

# Add inputs
Inputs can be named and then referred to in outputs. For example, you might want to allow plot variables to be changed.
To do that, you can add a select input with variables as options.

Change `site.R` to this:
```r
page_navbar("Site Title")
input_select("X Variable:", "variables", default = "x", id = "selected_x")
output_plot("selected_x", "y", "z")
```

Then rebuild:
```r
site_build(dir, bundle_data = TRUE)
```

# Add structure
`page_section` is the main way to arrange components of the site, which can be wrapped around any set of input or
output elements.

`page_menu` can be a nice way to arrange inputs.

These can be added to the previous example like this:
```r
page_navbar("Site Title")
page_menu(
  input_select("X Variable:", "variables", default = "x", id = "selected_x"),
  default_open = TRUE
)
page_section(
  wraps = "col",
  output_plot("selected_x", "y", "z")
)
```

# Add interactions
Plots (as well as maps) can be the source of mouse events (such as hovers and clicks). Information panes can
respond to these events by displaying additional information.

For example, we can tie a tooltip-like output to the plot like this:
```r
page_navbar("Site Title")
page_menu(
  input_select("X Variable:", "variables", default = "x", id = "selected_x"),
  default_open = TRUE
)
page_section(
  wraps = "col", sizes = c(8, 4),
  # give the plot an ID
  output_plot("selected_x", "y", "z", id = "main_plot"),
  # then make an information output that subscribes to it
  output_info("features.id", c("variables.short_name" = "value"), subto = "main_plot")
)
```

# Add variable information
The information output can also display additional information about the variables, which you can fill in when you
add the data.

For example, run the same `data_add` command as before, but include some information about one of the variables:
```r
data_add(
  paste0(dir, "/docs/data/data.csv"),
  list(
    variables = list(
      z = list(
        long_name = "Variable Z",
        description = "A random variable, drawn from a normal distribution.",
        statement = "{features.id} has a Z value of {value}"
      )
    )
  )
)
```

Then, you can draw from that in the information output in `site.R`:
```r
page_navbar("Site Title")
page_menu(
  input_select("X Variable:", "variables", default = "x", id = "selected_x"),
  default_open = TRUE
)
page_section(
  wraps = "col", sizes = c(8, 4),
  output_plot("selected_x", "y", "z", id = "main_plot"),
  output_info("features.name", c(
    "variables.long_name" = "value",
    "variables.description"
  ), subto = "main_plot")
)
```

By default, entries in `output_info` refer to the coloring variable, but this can be change by setting
`variable` to a variable name or ID of a variable selecting input.

# Add a Map
Maps will generally require shapes to be added from a separate, GeoJSON file. You can use the `download_census_shapes`
function to download shapes for Census regions within the United States.

For example, we might download the shapes of states:
```r
# save the state shapes to the distribution directory
download_census_shapes(paste0(dir, "/docs"), name = "states")
```

Then add a map to `site.R` (also subscribing the info pane to it):
```r
page_navbar("Site Title")
page_menu(
  input_select("X Variable:", "variables", default = "x", id = "selected_x"),
  default_open = TRUE
)
page_section(
  wraps = "col", sizes = c(8, 4),
  output_plot("selected_x", "y", "z", id = "main_plot"),
  output_info("features.id", c(
    "variables.long_name" = "value",
    "variables.description"
  ), subto = c("main_plot", "main_map"))
)
output_map(
  list(name = "data", url = paste0(dir, "/docs/states.geojson")),
  color = "selected_x", id = "main_map"
)
```

Because the shapes also had some properties, these were added as entity features, giving some names.